from tkinter import *
import numpy as np
root = Tk()

# select the size of mesh
height = 600
width = 1300
# select the number of meshes in both directions
xn=100
yn=50

count=0
height=(height//yn)*yn
width=(width//xn)*xn
y_cell=height//yn
x_cell=width//xn
mem=np.zeros([yn,xn],dtype=np.int16)
mem-=2
map=np.zeros([yn,xn],dtype=np.int8)

C = Canvas(root, bg="white", height=height, width=width)
C.pack()

for i in range (1,yn):
	C.create_line(0, y_cell*i, width, y_cell*i)
for i in range (1,xn):
	C.create_line(x_cell*i, 0, x_cell*i, height)

def create_barrier(event):
	pos=[event.y//y_cell,event.x//x_cell]
	cox=pos[1]*x_cell
	coy=pos[0]*y_cell
	C.create_rectangle(cox, coy, cox+x_cell, coy+y_cell, fill="black")
	map[pos[0],pos[1]]=-1

def define_nodes(event):
	global end
	global count
	global st
	if count==0:
		st=[event.y//y_cell,event.x//x_cell]
		count+=1
		cox=st[1]*x_cell 
		coy=st[0]*y_cell
		mem[st[0],st[1]]=0
		C.create_rectangle(cox, coy, cox+x_cell, coy+y_cell, fill="#fb0")
	elif count==1:
		end=[event.y//y_cell,event.x//x_cell]
		count+=1
		cox=end[1]*x_cell 
		coy=end[0]*y_cell
		C.create_rectangle(cox, coy, cox+x_cell, coy+y_cell, fill="#fb0")

def sweep():
	conta=0
	k=st[0]
	for i in range (k-1,-1,-1):
		if mem[i][st[1]]==-1:
			break
		conta+=1
	if conta==0:
		tax=st[0]
	else:
		tax=conta
	if tax%2==0:
		pass
		#leave one space
	else:
		pass
		#cover the whole

def assign_color(y,x,num):
	if num%5==0:
		C.create_rectangle(x, y, x+x_cell, y+y_cell, fill="blue")
		t = C.create_text(x+x_cell/2, y+y_cell/2, text=num)
	elif num%5==1:
		C.create_rectangle(x, y, x+x_cell, y+y_cell, fill="green")
		t = C.create_text(x+x_cell/2, y+y_cell/2, text=num)
	elif num%5==2:
		C.create_rectangle(x, y, x+x_cell, y+y_cell, fill="yellow")
		t = C.create_text(x+x_cell/2, y+y_cell/2, text=num)
	elif num%5==3:
		C.create_rectangle(x, y, x+x_cell, y+y_cell, fill="red")
		t = C.create_text(x+x_cell/2, y+y_cell/2, text=num)
	else:
		C.create_rectangle(x, y, x+x_cell, y+y_cell, fill="#fb0")
		t = C.create_text(x+x_cell/2, y+y_cell/2, text=num)

def closest_path(map,pos):
	stack0=np.zeros([xn+yn,2],dtype=np.int16)
	stack0-=1
	step=0
	stack0[0]=[pos[0],pos[1]]
	while stack0[0][0]!=-1:
		stack1=np.zeros([xn+yn,2],dtype=np.int16)
		stack1-=1
		ar=0
		for k in stack0:
			if k[0]!=-1:
				if k[0]<yn-1 and map[k[0]+1,k[1]]!=-1 and mem[k[0]+1,k[1]]==-2:
					stack1[ar]=[k[0]+1,k[1]]
					ar+=1
					mem[k[0]+1,k[1]]=step+1
					assign_color(y_cell*(k[0]+1),x_cell*k[1],step)
				if k[1]<xn-1 and map[k[0],k[1]+1]==0 and mem[k[0],k[1]+1]==-2:
					stack1[ar]=[k[0],k[1]+1]
					ar+=1
					mem[k[0],k[1]+1]=step+1
					assign_color(y_cell*k[0],x_cell*(k[1]+1),step)
				if k[0]>0 and map[k[0]-1,k[1]]==0 and mem[k[0]-1,k[1]]==-2:
					stack1[ar]=[k[0]-1,k[1]]
					ar+=1
					mem[k[0]-1,k[1]]=step+1
					assign_color(y_cell*(k[0]-1),x_cell*k[1],step)
				if k[1]>0 and map[k[0],k[1]-1]==0 and mem[k[0],k[1]-1]==-2:
					stack1[ar]=[k[0],k[1]-1]
					ar+=1
					mem[k[0],k[1]-1]=step+1
					assign_color(y_cell*k[0],x_cell*(k[1]-1),step)
		step+=1
		stack0=stack1

B1 = Button(root, text ="Find", relief=RAISED, command = lambda : closest_path(map,st))
B1.pack()
C.bind('<B1-Motion>', create_barrier)
C.bind('<Button-3>', define_nodes)

root.mainloop()
